<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>ASTEROIDS (Mobile Friendly)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: black;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center; /* Center content vertically */
        height: 100vh;
        font-family: monospace;
        color: white;
      }
      #game-container {
        display: flex;
        width: 100vw;
        height: 100vh;
        align-items: center;
        justify-content: center;
        flex-direction: row; /* Arrange canvas and controls horizontally */
      }
      #gameCanvas {
        border: 2px solid white;
        /* Adjust canvas size for horizontal layout */
        max-width: 70vh; /* Take up to 70% of viewport height */
        max-height: 100vh;
        width: auto;
        height: auto;
      }
      #mobile-controls {
        display: none; /* Hidden by default, shown on mobile */
        flex: 1;
        height: 100%;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-around;
      }
      .joystick-container,
      .button-container {
        width: 100px;
        height: 100px;
        position: relative;
      }
      .joystick,
      .shoot-button {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: 2px solid white;
        background-color: rgba(50, 50, 50, 0.7);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        cursor: pointer;
        touch-action: none; /* Prevent default touch actions */
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 1.2em;
      }
      .joystick-inner {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background-color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      #game-info {
        text-align: center;
        margin-bottom: 10px;
      }
      #controls {
        text-align: center;
        margin-top: 10px;
        font-size: smaller;
        color: #999;
      }
      #powerup-indicator {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 200, 0, 0.7);
        padding: 5px 10px;
        border-radius: 5px;
        display: none;
        color: black;
      }
      #powerup-timer {
        display: block;
        text-align: center;
      }
      .loading-circle {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 3px solid black;
        border-top: 3px solid transparent;
        animation: spin 1s linear infinite;
        margin: auto;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .ship-glow {
        filter: drop-shadow(0 0 8px white);
      }
      .restart-button {
        border: 2px solid white;
        padding: 10px 20px;
        color: white;
        background-color: transparent;
        cursor: pointer;
        font-family: monospace;
        font-size: 1em;
        margin-top: 15px;
      }
      .leaderboard {
        margin-top: 20px;
        text-align: left;
      }
      .leaderboard h2 {
        font-size: 1.2em;
        margin-bottom: 10px;
      }
      .leaderboard ol {
        padding-left: 20px;
      }
      .leaderboard li {
        margin-bottom: 5px;
      }
      .floating-text {
        position: absolute;
        animation: floatText 1s ease-out forwards;
        font-size: 1em;
        pointer-events: none;
      }
      @keyframes floatText {
        0% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-50px);
        }
      }
      #combo-text {
        position: absolute;
        top: 10px; /* Adjust as needed */
        left: 10px; /* Adjust as needed */
        font-size: 1.5em;
        color: orange;
        display: none;
      }
      /* Title Screen Styles */
      #title-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: black;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #start-button {
        border: 2px solid white;
        padding: 15px 30px;
        color: white;
        background-color: transparent;
        cursor: pointer;
        font-family: monospace;
        font-size: 1.2em;
        margin-top: 20px;
      }

      /* Mobile Specific Styles */
      @media (max-width: 768px) {
        body {
          flex-direction: column; /* Ensure title/game over screens are vertical */
        }
        #game-container {
          flex-direction: row; /* Keep canvas and controls horizontal */
        }
        #gameCanvas {
          max-width: 70vh; /* Adjust canvas size on mobile */
          max-height: none; /* Allow full height within its container */
          height: 100%;
        }
        #mobile-controls {
          display: flex; /* Show mobile controls on small screens */
        }
        #controls {
          display: none; /* Hide keyboard controls on mobile */
        }
        #game-info {
          position: absolute;
          top: 10px;
          left: 10px;
          text-align: left;
        }
        #combo-text {
          top: auto;
          bottom: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div id="title-screen">
      <h1>ASTEROIDS</h1>
      <p style="font-size: smaller">Coded with AI for the Browser</p>
      <button id="start-button">Start</button>
    </div>
    <div id="game-info">
      <h1>ASTEROIDS</h1>
      <p style="font-size: smaller">Coded with AI for the Browser</p>
      <p>Score: <span id="score">0</span> | Lives: <span id="lives">3</span></p>
    </div>
    <div id="game-container">
      <canvas id="gameCanvas"></canvas>
      <div id="mobile-controls">
        <div class="joystick-container">
          <div class="joystick">
            <div class="joystick-inner"></div>
          </div>
        </div>
        <div class="button-container">
          <div class="shoot-button">FIRE</div>
        </div>
      </div>
    </div>
    <div id="combo-text"></div>
    <div
      id="game-over"
      style="
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2em;
        text-align: center;
      "
    >
      <h1>Game Over</h1>
      <p>Final Score: <span id="final-score"></span></p>
      <p>Near Misses: <span id="final-near-misses"></span></p>
      <div id="restartButton" class="restart-button">Restart</div>
      <div id="leaderboard" class="leaderboard"></div>
    </div>
    <div id="controls">
      Controls: ←/A (Rotate Left), →/D (Rotate Right), ↑/W (Thrust), Spacebar
      (Fire), Shift (Hyperspace)
    </div>
    <div id="powerup-indicator">
      Power-up: <span id="powerup-name"></span>
      <div id="powerup-timer"></div>
    </div>

    <audio id="thrustSound" src="thrust.wav" preload="auto"></audio>
    <audio id="fireSound" src="fire.wav" preload="auto"></audio>
    <audio
      id="asteroidBreakSound"
      src="asteroid_break.wav"
      preload="auto"
    ></audio>
    <audio id="playerHitSound" src="player_hit.wav" preload="auto"></audio>
    <audio id="powerUpSound" src="powerup.wav" preload="auto"></audio>

    <script>
      const titleScreen = document.getElementById("title-screen");
      const startButton = document.getElementById("start-button");
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreDisplay = document.getElementById("score");
      const livesDisplay = document.getElementById("lives");
      const gameOverScreen = document.getElementById("game-over");
      const finalScoreDisplay = document.getElementById("final-score");
      const finalNearMissesDisplay =
        document.getElementById("final-near-misses");
      const powerupIndicator = document.getElementById("powerup-indicator");
      const powerupNameDisplay = document.getElementById("powerup-name");
      const powerupTimerDisplay = document.getElementById("powerup-timer");
      const restartButton = document.getElementById("restartButton");
      const leaderboardDisplay = document.getElementById("leaderboard");
      const comboTextDisplay = document.getElementById("combo-text");
      const gameInfoDisplay = document.getElementById("game-info");
      const controlsDisplay = document.getElementById("controls");
      const mobileControls = document.getElementById("mobile-controls");
      const joystick = document.querySelector(".joystick");
      const joystickInner = document.querySelector(".joystick-inner");
      const shootButton = document.querySelector(".shoot-button");

      const thrustSound = document.getElementById("thrustSound");
      const fireSound = document.getElementById("fireSound");
      const asteroidBreakSound = document.getElementById("asteroidBreakSound");
      const playerHitSound = document.getElementById("playerHitSound");
      const powerUpSound = document.getElementById("powerUpSound");

      let canvasWidth = canvas.clientWidth; // Use clientWidth for responsiveness
      let canvasHeight = canvas.clientHeight;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      let player;
      let asteroids = [];
      let projectiles = [];
      let powerUps = [];
      let extraLives = [];
      let score = 0;
      let lives = 3;
      let gameStarted = false;
      let gameOver = false;
      let isHyperspaceAvailable = true;
      let activePowerUp = null;
      let powerUpTimer = 0;
      let powerUpStartTime = 0;
      let nextPowerUpSpawnTime = 0;
      let shieldRadius = 25 * Math.min(canvasWidth / 800, canvasHeight / 600);
      let nextExtraLifeSpawnTime = 0;
      const trailLength = 30;
      let shipTrail = [];
      let gameScores = [];
      const numStars = 100;
      let stars = [];
      let asteroidFragments = [];
      let impactFlashes = [];
      let lastAsteroidHitTime = 0;
      let combo = 1;
      let nearMisses = 0;

      const baseScale = Math.min(canvasWidth / 800, canvasHeight / 600);

      const playerSettings = {
        x: canvasWidth / 2,
        y: canvasHeight / 2,
        angle: 0,
        velocity_x: 0,
        velocity_y: 0,
        rotation_speed: 0.05, // Adjusted rotation speed for touch
        acceleration: 0.15 * baseScale,
        friction: 0.985,
        max_speed: 5 * baseScale,
        base_radius: 10 * baseScale,
        front_offset: 18 * baseScale,
        front_width: 3 * baseScale,
        radius: 10 * baseScale,
        is_invulnerable: false,
        invulnerable_timer: 0,
        invulnerable_duration: 200,
        engine_glow_timer: 0,
      };

      const projectileSettings = {
        speed: 7 * baseScale,
        radius: 2 * baseScale,
        lifespan: 60,
        trailLength: 10,
      };

      const asteroidSettings = {
        min_speed: 1 * baseScale,
        max_speed: 3 * baseScale,
        fast_multiplier: 1.5,
        splitter_probability: 0.2,
        sizes: [30 * baseScale, 20 * baseScale, 10 * baseScale],
      };

      const powerUpSettings = {
        duration: 15,
        spawnIntervalMin: 20,
        spawnIntervalMax: 40,
        radius: 10 * baseScale,
      };

      const extraLifeSettings = {
        spawnIntervalMin: 30,
        spawnIntervalMax: 60,
        radius: 12 * baseScale,
        color: "gold",
        duration: 10, // Duration in seconds
      };

      const keyState = {};
      let joystickActive = false;
      let joystickDistance = 0;
      let joystickAngle = 0;

      const POWER_UP_TYPES = [
        { name: "Rapid Fire", color: "red" },
        { name: "Shield", color: "green" },
        { name: "Big Shot", color: "yellow" },
      ];

      function playSound(audioElement) {
        audioElement.currentTime = 0;
        audioElement.play();
      }

      function init() {
        canvasWidth = canvas.clientWidth;
        canvasHeight = canvas.clientHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        player = { ...playerSettings, x: canvasWidth / 2, y: canvasHeight / 2 };
        asteroids = [];
        projectiles = [];
        powerUps = [];
        extraLives = [];
        shipTrail = [];
        asteroidFragments = [];
        impactFlashes = [];
        score = 0;
        lives = 3;
        gameOver = false;
        isHyperspaceAvailable = true;
        activePowerUp = null;
        powerUpTimer = 0;
        powerUpStartTime = 0;
        nextPowerUpSpawnTime =
          performance.now() + getRandomSpawnInterval(powerUpSettings);
        nextExtraLifeSpawnTime =
          performance.now() + getRandomSpawnInterval(extraLifeSettings);
        scoreDisplay.textContent = score;
        livesDisplay.textContent = lives;
        gameOverScreen.style.display = "none";
        powerupIndicator.style.display = "none";
        lastAsteroidHitTime = 0;
        combo = 1;
        nearMisses = 0;
        spawnInitialAsteroids(5);
        initializeStars();
      }

      function startGame() {
        titleScreen.style.display = "none";
        gameInfoDisplay.style.display = "block";
        canvas.style.display = "block";
        controlsDisplay.style.display = !isMobileDevice(); // Show keyboard controls on desktop
        mobileControls.style.display = isMobileDevice() ? "flex" : "none"; // Show mobile controls on mobile
        gameStarted = true;
        init();
        draw();
      }

      function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      }

      function initializeStars() {
        for (let i = 0; i < numStars; i++) {
          stars.push({
            x: Math.random() * canvasWidth,
            y: Math.random() * canvasHeight,
            size: Math.random() * 2 + 1,
            opacity: Math.random() * 0.5 + 0.1,
          });
        }
      }

      function getRandomSpawnInterval(settings) {
        return (
          settings.spawnIntervalMin * 1000 +
          Math.random() *
            (settings.spawnIntervalMax - settings.spawnIntervalMin) *
            1000
        );
      }

      function spawnInitialAsteroids(count) {
        for (let i = 0; i < count; i++) {
          spawnAsteroid(0);
        }
      }

      function spawnAsteroid(sizeIndex, parentAsteroid) {
        // ... (rest of the spawnAsteroid function is the same)
        const size = asteroidSettings.sizes[sizeIndex];
        let x, y, angle;
        let velocity_x, velocity_y;
        let isFast = false;
        let isSplitter = false;

        if (parentAsteroid) {
          x = parentAsteroid.x;
          y = parentAsteroid.y;
          angle = Math.random() * Math.PI * 2;
          const speed =
            asteroidSettings.min_speed +
            Math.random() *
              (asteroidSettings.max_speed - asteroidSettings.min_speed);
          velocity_x =
            parentAsteroid.velocity_x * 0.5 + Math.cos(angle) * speed;
          velocity_y =
            parentAsteroid.velocity_y * 0.5 + Math.sin(angle) * speed;
        } else {
          const edge = Math.floor(Math.random() * 4);
          if (edge === 0) {
            x = Math.random() * canvasWidth;
            y = -size;
            angle = Math.random() * Math.PI;
          } else if (edge === 1) {
            x = canvasWidth + size;
            y = Math.random() * canvasHeight;
            angle = Math.random() * Math.PI + Math.PI / 2;
          } else if (edge === 2) {
            x = Math.random() * canvasWidth;
            y = canvasHeight + size;
            angle = Math.random() * Math.PI + Math.PI;
          } else {
            x = -size;
            y = Math.random() * canvasHeight;
            angle = Math.random() * Math.PI - Math.PI / 2;
          }
          const speed =
            asteroidSettings.min_speed +
            Math.random() *
              (asteroidSettings.max_speed - asteroidSettings.min_speed);
          velocity_x = Math.cos(angle) * speed;
          velocity_y = Math.sin(angle) * speed;
          if (Math.random() < 0.1) isFast = true;
          if (Math.random() < asteroidSettings.splitter_probability)
            isSplitter = true;
        }

        const speedMultiplier = isFast ? asteroidSettings.fast_multiplier : 1;
        const shape = generateAsteroidShape(size);

        asteroids.push({
          x,
          y,
          radius: size,
          velocity_x: velocity_x * speedMultiplier,
          velocity_y: velocity_y * speedMultiplier,
          size_type: sizeIndex,
          shape: shape,
          colorVariation: `rgba(128, 128, 128, ${0.8 + Math.random() * 0.2})`,
          isSplitter: isSplitter,
          nearMissAwarded: false,
        });
      }

      function generateAsteroidShape(radius) {
        const vertices = 8 + Math.floor(Math.random() * 5);
        const shape = [];
        for (let i = 0; i < vertices; i++) {
          const angle = ((Math.PI * 2) / vertices) * i;
          const variation = 0.7 + Math.random() * 0.6;
          const x = Math.cos(angle) * radius * variation;
          const y = Math.sin(angle) * radius * variation;
          shape.push({ x, y });
        }
        return shape;
      }

      function spawnPowerUp() {
        const now = performance.now();
        if (
          now >= nextPowerUpSpawnTime &&
          !activePowerUp &&
          powerUps.length === 0
        ) {
          const x = Math.random() * canvasWidth;
          const y = Math.random() * canvasHeight;
          const type =
            POWER_UP_TYPES[Math.floor(Math.random() * POWER_UP_TYPES.length)];
          powerUps.push({ x, y, type });
          nextPowerUpSpawnTime =
            performance.now() + getRandomSpawnInterval(powerUpSettings);
        }
      }

      function spawnExtraLife() {
        const now = performance.now();
        if (now >= nextExtraLifeSpawnTime && extraLives.length === 0) {
          const x = Math.random() * canvasWidth * 0.8 + canvasWidth * 0.1;
          const y = Math.random() * canvasHeight * 0.8 + canvasHeight * 0.1;
          extraLives.push({
            x: x,
            y: y,
            radius: extraLifeSettings.radius,
            spawnTime: now, // Record the time of spawning
          });
          nextExtraLifeSpawnTime =
            performance.now() + getRandomSpawnInterval(extraLifeSettings);
        }
      }

      function createProjectile() {
        const angle = player.angle;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        let speed = projectileSettings.speed;
        let radius = projectileSettings.radius;

        if (activePowerUp && activePowerUp.name === "Rapid Fire") {
          speed *= 1.5;
        }
        if (activePowerUp && activePowerUp.name === "Big Shot") {
          radius *= 10; // Increased to 5 times bigger
        }

        projectiles.push({
          x: player.x + cos * playerSettings.front_offset,
          y: player.y + sin * playerSettings.front_offset,
          velocity_x: player.velocity_x + cos * speed,
          velocity_y: player.velocity_y + sin * speed,
          lifespan: projectileSettings.lifespan,
          radius: radius,
          trail: [],
        });
        playSound(fireSound);
      }

      function updatePlayer() {
        if (!isMobileDevice()) {
          if (keyState["ArrowLeft"] || keyState["KeyA"]) {
            player.angle -= playerSettings.rotation_speed;
          }
          if (keyState["ArrowRight"] || keyState["KeyD"]) {
            player.angle += playerSettings.rotation_speed;
          }
          if (keyState["ArrowUp"] || keyState["KeyW"]) {
            player.velocity_x +=
              Math.cos(player.angle) * playerSettings.acceleration;
            player.velocity_y +=
              Math.sin(player.angle) * playerSettings.acceleration;
            player.engine_glow_timer = 5;
            if (performance.now() % 5 < 1) {
              playSound(thrustSound);
            }
          }
        } else if (joystickActive) {
          player.angle += joystickAngle;
          if (joystickDistance > 0) {
            player.velocity_x +=
              Math.cos(player.angle) *
              playerSettings.acceleration *
              (joystickDistance / 50); // Adjust sensitivity
            player.velocity_y +=
              Math.sin(player.angle) *
              playerSettings.acceleration *
              (joystickDistance / 50);
            player.engine_glow_timer = 5;
            if (performance.now() % 5 < 1) {
              playSound(thrustSound);
            }
          }
        }

        const currentSpeed = Math.sqrt(
          player.velocity_x ** 2 + player.velocity_y ** 2
        );
        if (currentSpeed > playerSettings.max_speed) {
          const ratio = playerSettings.max_speed / currentSpeed;
          player.velocity_x *= ratio;
          player.velocity_y *= ratio;
        }

        player.velocity_x *= playerSettings.friction;
        player.velocity_y *= playerSettings.friction;
        player.x += player.velocity_x;
        player.y += player.velocity_y;

        if (player.x < 0 - playerSettings.front_offset)
          player.x = canvasWidth + playerSettings.front_offset;
        if (player.x > canvasWidth + playerSettings.front_offset)
          player.x = 0 - playerSettings.front_offset;
        if (player.y < 0 - playerSettings.front_offset)
          player.y = canvasHeight + playerSettings.front_offset;
        if (player.y > canvasHeight + playerSettings.front_offset)
          player.y = 0 - playerSettings.front_offset;

        if (player.is_invulnerable) {
          player.invulnerable_timer--;
          if (player.invulnerable_timer <= 0) {
            player.is_invulnerable = false;
          }
        }

        shipTrail.push({ x: player.x, y: player.y });
        if (shipTrail.length > trailLength) {
          shipTrail.shift();
        }

        if (player.engine_glow_timer > 0) {
          player.engine_glow_timer--;
        }
      }

      function updateAsteroids() {
        // ... (rest of the updateAsteroids function is the same)
        for (let i = 0; i < asteroids.length; i++) {
          asteroids[i].x += asteroids[i].velocity_x;
          asteroids[i].y += asteroids[i].velocity_y;

          const size = asteroids[i].radius;
          if (asteroids[i].x < 0 - size) asteroids[i].x = canvasWidth + size;
          if (asteroids[i].x > canvasWidth + size) asteroids[i].x = 0 - size;
          if (asteroids[i].y < 0 - size) asteroids[i].y = canvasHeight + size;
          if (asteroids[i].y > canvasHeight + size) asteroids[i].y = 0 - size;
        }
      }

      function updateProjectiles() {
        // ... (rest of the updateProjectiles function is the same)
        for (let i = projectiles.length - 1; i >= 0; i--) {
          projectiles[i].x += projectiles[i].velocity_x;
          projectiles[i].y += projectiles[i].velocity_y;
          projectiles[i].lifespan--;
          projectiles[i].trail.push({
            x: projectiles[i].x,
            y: projectiles[i].y,
          });
          if (projectiles[i].trail.length > projectileSettings.trailLength) {
            projectiles[i].trail.shift();
          }

          if (
            projectiles[i].x < 0 ||
            projectiles[i].x > canvasWidth ||
            projectiles[i].y < 0 ||
            projectiles[i].y > canvasHeight ||
            projectiles[i].lifespan <= 0
          ) {
            projectiles.splice(i, 1);
          }
        }
      }

      function updatePowerUps() {
        // ... (rest of the updatePowerUps function is the same)
        if (activePowerUp) {
          const elapsedTime = performance.now() - powerUpStartTime;
          const remainingTime = Math.max(
            0,
            powerUpSettings.duration * 1000 - elapsedTime
          );
          powerUpTimer = Math.ceil(remainingTime / 1000);

          if (remainingTime <= 0) {
            activePowerUp = null;
            powerupIndicator.style.display = "none";
          } else {
            powerupTimerDisplay.textContent = powerUpTimer;
          }
        } else {
          spawnPowerUp();
        }
      }

      function updateExtraLives() {
        // ... (rest of the updateExtraLives function is the same)
        spawnExtraLife();
        const now = performance.now();
        for (let i = extraLives.length - 1; i >= 0; i--) {
          if (
            now - extraLives[i].spawnTime >
            extraLifeSettings.duration * 1000
          ) {
            extraLives.splice(i, 1);
          }
        }
      }

      function createImpactFlash(x, y, lastHit) {
        // ... (rest of the createImpactFlash function is the same)
        let color = "rgba(255, 255, 0, 0.8)"; // Default yellow
        const now = performance.now();
        if (lastHit) {
          const timeDiff = now - lastHit;
          if (timeDiff < 100) {
            color = "rgba(255, 200, 0, 0.8)"; // Slightly orange
          } else if (timeDiff < 200) {
            color = "rgba(255, 150, 0, 0.8)"; // More orange
          }
        }
        impactFlashes.push({
          x: x,
          y: y,
          radius: 10,
          lifespan: 10,
          color: color,
        });
      }

      function updateImpactFlashes() {
        // ... (rest of the updateImpactFlashes function is the same)
        for (let i = impactFlashes.length - 1; i >= 0; i--) {
          impactFlashes[i].lifespan--;
          impactFlashes[i].radius += 1;
          if (impactFlashes[i].lifespan <= 0) {
            impactFlashes.splice(i, 1);
          }
        }
      }
      function createAsteroidFragments(asteroid) {
        const numFragments = 5 + Math.floor(Math.random() * 5);
        for (let i = 0; i < numFragments; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 3;
          asteroidFragments.push({
            x: asteroid.x,
            y: asteroid.y,
            velocityX: Math.cos(angle) * speed,
            velocityY: Math.sin(angle) * speed,
            radius: 1 + Math.random() * 3,
            lifespan: 30 + Math.floor(Math.random() * 20),
            color: asteroid.colorVariation,
          });
        }
      }

      function updateAsteroidFragments() {
        for (let i = asteroidFragments.length - 1; i >= 0; i--) {
          asteroidFragments[i].x += asteroidFragments[i].velocityX;
          asteroidFragments[i].y += asteroidFragments[i].velocityY;
          asteroidFragments[i].lifespan--;
          if (asteroidFragments[i].lifespan <= 0) {
            asteroidFragments.splice(i, 1);
          }
        }
      }

      function displayFloatingText(text, x, y) {
        const floatingText = document.createElement("div");
        floatingText.className = "floating-text";
        floatingText.textContent = text;
        floatingText.style.left = `${x}px`;
        floatingText.style.top = `${y}px`;
        document.body.appendChild(floatingText);
        setTimeout(() => {
          floatingText.remove();
        }, 1000);
      }

      function checkCollisions() {
        if (!player.is_invulnerable) {
          for (let i = 0; i < asteroids.length; i++) {
            const dx = player.x - asteroids[i].x;
            const dy = player.y - asteroids[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (
              distance < playerSettings.radius + asteroids[i].radius &&
              !(activePowerUp && activePowerUp.name === "Shield")
            ) {
              lives--;
              livesDisplay.textContent = lives;
              player.x = canvasWidth / 2;
              player.y = canvasHeight / 2;
              player.velocity_x = 0;
              player.velocity_y = 0;
              player.is_invulnerable = true;
              player.invulnerable_timer = playerSettings.invulnerable_duration;
              shipTrail = [];
              createImpactFlash(player.x, player.y);
              playSound(playerHitSound);

              if (lives <= 0) {
                gameOver = true;
                finalScoreDisplay.textContent = score;
                finalNearMissesDisplay.textContent = nearMisses;
                updateLeaderboard();
                displayLeaderboard();
                gameOverScreen.style.display = "block";
              }
              break;
            } else if (
              distance < playerSettings.radius + asteroids[i].radius + 30 &&
              !asteroids[i].nearMissAwarded
            ) {
              nearMisses++;
              displayFloatingText("Near Miss!", player.x, player.y - 40);
              asteroids[i].nearMissAwarded = true;
            } else if (
              distance >
              playerSettings.radius + asteroids[i].radius + 50
            ) {
              asteroids[i].nearMissAwarded = false;
            }
          }
        }

        for (let i = projectiles.length - 1; i >= 0; i--) {
          for (let j = asteroids.length - 1; j >= 0; j--) {
            const dx = projectiles[i].x - asteroids[j].x;
            const dy = projectiles[i].y - asteroids[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < projectiles[i].radius + asteroids[j].radius) {
              let points =
                asteroids[j].size_type === 0
                  ? 20
                  : asteroids[j].size_type === 1
                  ? 50
                  : 100;
              const now = performance.now();
              if (now - lastAsteroidHitTime < 1000) {
                combo++;
              } else {
                combo = 1;
              }
              lastAsteroidHitTime = now;
              points *= combo;
              score += points;
              scoreDisplay.textContent = score;
              createImpactFlash(
                projectiles[i].x,
                projectiles[i].y,
                asteroids[j].lastHitTime
              );
              asteroids[j].lastHitTime = now;
              createAsteroidFragments(asteroids[j]);
              playSound(asteroidBreakSound);
              if (combo > 1) {
                comboTextDisplay.textContent = `Combo x${combo}!`;
                comboTextDisplay.style.display = "block";
                setTimeout(() => {
                  comboTextDisplay.style.display = "none";
                }, 1000);
                displayFloatingText(
                  `+${points}`,
                  asteroids[j].x,
                  asteroids[j].y - asteroids[j].radius - 10
                );
              } else {
                displayFloatingText(
                  `+${points}`,
                  asteroids[j].x,
                  asteroids[j].y - asteroids[j].radius - 10
                );
              }

              if (asteroids[j].isSplitter && asteroids[j].size_type < 2) {
                const newSizeIndex = asteroids[j].size_type + 1;
                for (let k = 0; k < 3; k++) {
                  spawnAsteroid(newSizeIndex, asteroids[j]);
                }
              } else if (asteroids[j].size_type < 2) {
                const newSizeIndex = asteroids[j].size_type + 1;
                for (let k = 0; k < 2 + Math.floor(Math.random() * 2); k++) {
                  spawnAsteroid(newSizeIndex, asteroids[j]);
                }
              }
              asteroids.splice(j, 1);
              projectiles.splice(i, 1);
              break;
            }
          }
        }

        for (let i = powerUps.length - 1; i >= 0; i--) {
          const dx = player.x - powerUps[i].x;
          const dy = player.y - powerUps[i].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < playerSettings.radius + powerUpSettings.radius) {
            activePowerUp = powerUps[i].type;
            powerUpStartTime = performance.now();
            powerupNameDisplay.textContent = activePowerUp.name;
            powerupIndicator.style.backgroundColor = activePowerUp.color;
            powerupTimerDisplay.textContent = powerUpSettings.duration;
            powerupIndicator.style.display = "block";
            playSound(powerUpSound);
            powerUps.splice(i, 1);
          }
        }

        for (let i = extraLives.length - 1; i >= 0; i--) {
          const dx = player.x - extraLives[i].x;
          const dy = player.y - extraLives[i].y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < playerSettings.radius + extraLives[i].radius) {
            lives++;
            livesDisplay.textContent = lives;
            playSound(powerUpSound);
            extraLives.splice(i, 1);
          }
        }

        if (activePowerUp && activePowerUp.name === "Shield") {
          for (let i = asteroids.length - 1; i >= 0; i--) {
            const dx = player.x - asteroids[i].x;
            const dy = player.y - asteroids[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < shieldRadius + asteroids[i].radius) {
              score +=
                asteroids[i].size_type === 0
                  ? 20
                  : asteroids[i].size_type === 1
                  ? 50
                  : 100;
              scoreDisplay.textContent = score;
              createImpactFlash(
                asteroids[i].x,
                asteroids[i].y,
                asteroids[i].lastHitTime
              );
              createAsteroidFragments(asteroids[i]);
              playSound(asteroidBreakSound);
              asteroids.splice(i, 1);
            }
          }
        }

        if (asteroids.length === 0 && !gameOver) {
          spawnInitialAsteroids(Math.min(10, 5 + Math.floor(score / 500)));
        }
      }

      function drawStars() {
        stars.forEach((star) => {
          ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawShipTrail() {
        ctx.lineWidth = 2;
        for (let i = 0; i < shipTrail.length; i++) {
          let transparency = (i + 1) / shipTrail.length;
          ctx.strokeStyle = `rgba(255, 0, 0, ${transparency})`;

          if (i > 0) {
            ctx.beginPath();
            ctx.moveTo(shipTrail[i - 1].x, shipTrail[i - 1].y);
            ctx.lineTo(shipTrail[i].x, shipTrail[i].y);
            ctx.stroke();
          }
        }
      }

      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);

        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";

        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(playerSettings.front_offset, 0);
        ctx.lineTo(
          -playerSettings.base_radius * 0.7,
          playerSettings.base_radius * 0.7
        );
        ctx.lineTo(
          -playerSettings.base_radius * 0.7,
          -playerSettings.base_radius * 0.7
        );
        ctx.closePath();
        ctx.stroke();

        if (player.engine_glow_timer > 0) {
          ctx.fillStyle = `rgba(255, 165, 0, ${player.engine_glow_timer / 5})`;
          ctx.beginPath();
          ctx.moveTo(-playerSettings.front_offset * 0.5, 0);
          ctx.lineTo(
            -playerSettings.base_radius * 1.5,
            playerSettings.base_radius * 0.6
          );
          ctx.lineTo(
            -playerSettings.base_radius * 1.5,
            -playerSettings.base_radius * 0.6
          );
          ctx.closePath();
          ctx.fill();
        }

        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(playerSettings.front_offset * 1.5, 0);
        ctx.stroke();

        ctx.restore();

        if (activePowerUp && activePowerUp.name === "Shield") {
          ctx.strokeStyle = "green";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(player.x, player.y, shieldRadius, 0, Math.PI * 2);
          ctx.stroke();
        }

        if (
          player.is_invulnerable &&
          Math.floor(performance.now() / 100) % 2 === 0
        ) {
          // Optional: visual feedback for invulnerability
        }

        drawShipTrail();
      }

      function drawAsteroids() {
        asteroids.forEach((asteroid) => {
          ctx.strokeStyle = asteroid.colorVariation;
          ctx.lineWidth = 2;
          ctx.beginPath();
          asteroid.shape.forEach((vertex, index) => {
            const x = asteroid.x + vertex.x;
            const y = asteroid.y + vertex.y;
            if (index === 0) {
              ctx.moveTo(x, y);
            } else {
              const prevVertex = asteroid.shape[index - 1];
              ctx.lineTo(x, y);
            }
          });
          ctx.closePath();
          ctx.stroke();
        });
      }

      function drawProjectiles() {
        projectiles.forEach((projectile) => {
          ctx.fillStyle = "lime";
          ctx.beginPath();
          ctx.arc(
            projectile.x,
            projectile.y,
            projectile.radius,
            0,
            Math.PI * 2
          );
          ctx.fill();

          ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
          ctx.lineWidth = 1;
          for (let i = 1; i < projectile.trail.length; i++) {
            ctx.beginPath();
            ctx.moveTo(projectile.trail[i - 1].x, projectile.trail[i - 1].y);
            ctx.lineTo(projectile.trail[i].x, projectile.trail[i].y);
            ctx.stroke();
          }
        });
      }

      function drawPowerUps() {
        powerUps.forEach((powerUp) => {
          ctx.fillStyle = powerUp.type.color;
          ctx.beginPath();
          ctx.arc(powerUp.x, powerUp.y, powerUpSettings.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "black";
          ctx.font = `bold ${10 * baseScale}px monospace`;
          ctx.textAlign = "center";
          ctx.fillText(
            powerUp.type.name.substring(0, 1),
            powerUp.x,
            powerUp.y + 4 * baseScale
          );
        });
      }

      function drawExtraLives() {
        extraLives.forEach((extraLife) => {
          ctx.fillStyle = extraLifeSettings.color;
          ctx.beginPath();
          ctx.arc(extraLife.x, extraLife.y, extraLife.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(extraLife.x - extraLife.radius / 2, extraLife.y);
          ctx.lineTo(extraLife.x + extraLife.radius / 2, extraLife.y);
          ctx.moveTo(extraLife.x, extraLife.y - extraLife.radius / 2);
          ctx.lineTo(extraLife.x, extraLife.y + extraLife.radius / 2);
          ctx.stroke();
        });
      }

      function drawImpactFlashes() {
        impactFlashes.forEach((flash) => {
          ctx.fillStyle = flash.color;
          ctx.beginPath();
          ctx.arc(flash.x, flash.y, flash.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawAsteroidFragments() {
        asteroidFragments.forEach((fragment) => {
          ctx.fillStyle = fragment.color;
          ctx.beginPath();
          ctx.arc(fragment.x, fragment.y, fragment.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function draw() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        drawStars();

        if (gameStarted && !gameOver) {
          updatePlayer();
          updateAsteroids();
          updateProjectiles();
          updatePowerUps();
          updateExtraLives();
          updateImpactFlashes();
          updateAsteroidFragments();
          checkCollisions();
          drawPlayer();
          drawAsteroids();
          drawProjectiles();
          drawPowerUps();
          drawExtraLives();
          drawImpactFlashes();
          drawAsteroidFragments();
        }
        requestAnimationFrame(draw);
      }

      function resetGame() {
        init();
        gameOverScreen.style.display = "none";
        gameStarted = true;
        canvas.style.display = "block";
        gameInfoDisplay.style.display = "block";
        controlsDisplay.style.display = !isMobileDevice();
        mobileControls.style.display = isMobileDevice() ? "flex" : "none";
      }

      function hyperspace() {
        if (isHyperspaceAvailable && gameStarted && !gameOver) {
          player.x = Math.random() * canvasWidth;
          player.y = Math.random() * canvasHeight;
          player.velocity_x = 0;
          player.velocity_y = 0;
          player.is_invulnerable = true;
          player.invulnerable_timer = playerSettings.invulnerable_duration * 2;
          isHyperspaceAvailable = false;
          setTimeout(() => {
            isHyperspaceAvailable = true;
          }, 3000);
        }
      }

      function updateLeaderboard() {
        gameScores.push(score);
        gameScores.sort((a, b) => b - a);
        gameScores = gameScores.slice(0, 5);
      }

      function displayLeaderboard() {
        leaderboardDisplay.innerHTML = "<h2>Top Scores</h2>";
        if (gameScores.length > 0) {
          const list = document.createElement("ol");
          gameScores.forEach((s) => {
            const item = document.createElement("li");
            item.textContent = s;
            list.appendChild(item);
          });
          leaderboardDisplay.appendChild(list);
        } else {
          leaderboardDisplay.innerHTML += "<p>No scores yet.</p>";
        }
      }

      document.addEventListener("keydown", (e) => {
        if (!isMobileDevice()) {
          keyState[e.code] = true;
          if (gameStarted && e.code === "Space" && !gameOver) {
            createProjectile();
          }
          if (gameStarted && e.code === "Shift") {
            hyperspace();
          }
        }
        if (e.code === "KeyR" && gameOver) {
          resetGame();
        }
      });

      document.addEventListener("keyup", (e) => {
        if (!isMobileDevice()) {
          keyState[e.code] = false;
        }
      });

      startButton.addEventListener("click", startGame);
      restartButton.addEventListener("click", resetGame);

      // Mobile controls event listeners
      joystick.addEventListener("touchstart", (e) => {
        joystickActive = true;
      });

      joystick.addEventListener("touchmove", (e) => {
        if (!joystickActive) return;
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const touch = e.touches[0];
        const deltaX = touch.clientX - centerX;
        const deltaY = touch.clientY - centerY;
        joystickDistance = Math.min(50, Math.sqrt(deltaX ** 2 + deltaY ** 2));
        joystickAngle = Math.atan2(deltaX, -deltaY) / 50; // Adjust sensitivity
        const innerX = deltaX * (joystickDistance / 50);
        const innerY = deltaY * (joystickDistance / 50);
        joystickInner.style.transform = `translate(${innerX}px, ${innerY}px)`;
      });

      joystick.addEventListener("touchend", () => {
        joystickActive = false;
        joystickDistance = 0;
        joystickAngle = 0;
        joystickInner.style.transform = `translate(0px, 0px)`;
      });

      shootButton.addEventListener("touchstart", (e) => {
        e.preventDefault(); // Prevent potential double tap zoom
        if (gameStarted && !gameOver) {
          createProjectile();
        }
      });

      // Initial drawing of stars on the title screen
      function drawTitleScreen() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        drawStars();
        requestAnimationFrame(drawTitleScreen);
      }
      drawTitleScreen();
    </script>
  </body>
</html>
